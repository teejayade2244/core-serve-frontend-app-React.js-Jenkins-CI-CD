variables:
- group: MyProject-Env-Dev

trigger:
  branches:
    include:
      - master 
      - feature/* 
pr:
  branches:
    include:
      - "*" 

pool:
  name: MyLinuxAgents 

stages:
- stage: BuildAndTest
  displayName: 'Build and Test Frontend'
  jobs:
  - job: FrontendCI
    displayName: 'Frontend Continuous Integration (Build, Unit Tests and Dependency scans)'
    pool:
      name: MyLinuxAgents
    steps:
    - task: Bash@3 
      displayName: 'Clean node_modules and package-lock.json for PRs'
      inputs:
        targetType: 'inline'
        script: |
          # Azure DevOps built-in variables for branch name:
          # Build.SourceBranch (e.g., refs/heads/master, refs/pull/123/merge)
          # Build.SourceBranchName (e.g., master, pull/123/merge)
          # System.PullRequest.PullRequestNumber (if it's a PR build)
          
          # Check if it's a PR build by looking for System.PullRequest.PullRequestNumber
          # Or, check if the branch name contains 'pull/'
          if [[ "$(Build.SourceBranch)" == refs/pull/* ]]; then
            echo "This is a PR branch. Cleaning workspace before npm install."
            rm -rf node_modules package-lock.json || true
          else
            echo "Not a PR branch. Skipping pre-install cleanup."
          fi
        workingDirectory: '$(Build.SourcesDirectory)' # Ensure it runs in the repo root

    # Using Node.js Tool Installer task for specific Node.js version
    # ────── Setup and Install ──────
    - task: NodeTool@0
      displayName: 'Use Node.js 22.x' 
      inputs:
        versionSpec: '22.x' 

    - script: npm install --no-audit
      displayName: 'Install Node.js Dependencies'
      workingDirectory: '$(Build.SourcesDirectory)'

    - script: |
        echo "Running NPM Audit..."
        npm audit --audit-level=critical
      displayName: 'Run NPM Audit'
      workingDirectory: '$(Build.SourcesDirectory)'

    # ────── OWASP Dependency Check ──────
    # - bash: 'mkdir -p OWASP-security-reports'
    #   displayName: 'Create OWASP Security Reports Directory'
    #   workingDirectory: '$(Build.SourcesDirectory)'
    
    # - task: dependency-check-build-task@6
    #   displayName: 'Run OWASP Dependency Check'
    #   inputs:
    #     projectName: 'core-serve-frontend-app'
    #     scanPath: '$(Build.SourcesDirectory)'
    #     format: 'HTML'
    #     uploadReports: true
    #     failOnCVSS: '8'
    #     enableVerbose: true
    #     nvdApiKey: '$(NVD_API_KEY)' 

    # - task: PublishBuildArtifacts@1
    #   displayName: 'Publish OWASP Reports'
    #   inputs:
    #     pathToPublish: '$(Build.SourcesDirectory)/OWASP-security-reports'
    #     artifactName: 'OWASPReports'

    # Create a directory for test results
    # ────── Unit Tests ──────
    - bash: 'mkdir -p test-results'
      displayName: 'Create Test Results Directory'
      workingDirectory: '$(Build.SourcesDirectory)'

    - script: npm test
      displayName: 'Run Unit Tests'
      workingDirectory: '$(Build.SourcesDirectory)'

    # Publish test results (assuming 'npm test' generates a JUnit-compatible report)
    - task: PublishTestResults@2
      displayName: 'Publish Unit Test Results'
      inputs:
        testResultsFormat: 'JUnit' 
        testResultsFiles: '**/junit.xml' 
        mergeResults: true
        failTaskOnFailedTests: true


- stage: SonarQubeAnalysis
  displayName: 'Static Analysis with SonarQube'
  jobs:
  - job: SonarScan
    displayName: 'Run SonarQube Scan'
    pool:
      name: MyLinuxAgents
    steps:
    - task: SonarQubePrepare@5
      displayName: 'Prepare SonarQube Analysis'
      inputs:
          SonarQube: 'sonarqube' # IMPORTANT: Ensure this is the EXACT name of your SonarQube Service Connection
          scannerMode: 'CLI'
          configMode: 'manual'
          cliProjectKey: $(SONARQUBE_PROJECT_KEY)
          cliProjectName: 'temitope'
          extraProperties: |
              sonar.sources=src
              sonar.exclusions=**/node_modules/**,**/bin/**,**/obj/**
            

    - task: SonarQubeAnalyze@5
      displayName: 'Run SonarQube Analysis'
     
    # - task: PublishBuildArtifacts@1
    #   displayName: 'Publish SonarQube Reports'
    #   inputs:
    #     pathToPublish: '$(Build.SourcesDirectory)/.scannerwork/report-task.txt' 
    #     artifactName: 'SonarQubeReports'

    - task: SonarQubePublish@5
      displayName: 'Publish SonarQube Results and Wait for Quality Gate'
      inputs:
        pollingTimeoutSec: '300' 


- stage: BuildAndScanDockerImage
  displayName: 'Build & Scan Docker Image'
  jobs:
  - job: DockerImageOps
    displayName: 'Docker Image Build & Trivy Scan'
    pool:
      name: MyLinuxAgents
    variables:
      IMAGE_TAG: '$(Build.BuildId)' 
      DOCKER_IMAGE_FULL_NAME: '$(ACR_REGISTRY_SERVER)/$(ACR_REPOSITORY_NAME):$(IMAGE_TAG)'
    steps:
    # Login to Azure Container Registry (ACR)
    - task: Docker@2
      displayName: 'Login to ACR'
      inputs:
        containerRegistry: 'my-acr-connection' 
        command: 'login'

    # Build and Tag Docker Image
    - task: Docker@2
      displayName: 'Build and Tag Docker Image for ACR'
      inputs:
        containerRegistry: 'my-acr-connection' 
        repository: '$(ACR_REPOSITORY_NAME)' 
        command: 'build'
        Dockerfile: 'Dockerfile' 
        tags: '$(IMAGE_TAG)' 
        buildContext: '$(Build.SourcesDirectory)' 

    # Trivy Vulnerability Scan
    - bash: 'mkdir -p Trivy-Image-Reports'
      displayName: 'Create Trivy Reports Directory'
      workingDirectory: '$(Build.SourcesDirectory)'

    - script: |
        echo "Running Trivy Scan for MEDIUM severity..."
        trivy image $(DOCKER_IMAGE_FULL_NAME) \
          --severity LOW,MEDIUM \
          --exit-code 0 \
          --quiet \
          --format json -o Trivy-Image-Reports/trivy-image-MEDIUM-results.json

        echo "Running Trivy Scan for CRITICAL severity..."
        trivy image $(DOCKER_IMAGE_FULL_NAME) \
          --severity CRITICAL \
          --exit-code 1 \
          --quiet \
          --format json -o Trivy-Image-Reports/trivy-image-CRITICAL-results.json
      displayName: 'Run Trivy Vulnerability Scan'
      workingDirectory: '$(Build.SourcesDirectory)'

    # Convert Trivy reports to HTML and XML
    # IMPORTANT: Ensure Trivy templates (html.tpl, junit.tpl) are present on your agent at `/usr/local/share/trivy/templates/`.
    - script: |
        echo "Converting Trivy JSON reports to HTML and XML..."
        trivy convert \
          --format template --template "@/usr/local/share/trivy/templates/html.tpl" \
          --output Trivy-Image-Reports/trivy-image-MEDIUM-results.html Trivy-Image-Reports/trivy-image-MEDIUM-results.json

        trivy convert \
          --format template --template "@/usr/local/share/trivy/templates/html.tpl" \
          --output Trivy-Image-Reports/trivy-image-CRITICAL-results.html Trivy-Image-Reports/trivy-image-CRITICAL-results.json

        trivy convert \
          --format template --template "@/usr/local/share/trivy/templates/junit.tpl" \
          --output Trivy-Image-Reports/trivy-image-MEDIUM-results.xml Trivy-Image-Reports/trivy-image-MEDIUM-results.json

        trivy convert \
          --format template --template "@/usr/local/share/trivy/templates/junit.tpl" \
          --output Trivy-Image-Reports/trivy-image-CRITICAL-results.xml Trivy-Image-Reports/trivy-image-CRITICAL-results.json
      displayName: 'Convert Trivy Reports'
      workingDirectory: '$(Build.SourcesDirectory)'

    # Publish Trivy reports as build artifacts
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Trivy Reports'
      inputs:
        pathToPublish: '$(Build.SourcesDirectory)/Trivy-Image-Reports'
        artifactName: 'TrivyReports'

    # Push Docker Image to ACR
    - task: Docker@2
      displayName: 'Push Docker Image to ACR'
      inputs:
        containerRegistry: 'my-acr-connection' 
        repository: '$(ACR_REPOSITORY_NAME)' 
        command: 'push'
        tags: '$(IMAGE_TAG)' 
